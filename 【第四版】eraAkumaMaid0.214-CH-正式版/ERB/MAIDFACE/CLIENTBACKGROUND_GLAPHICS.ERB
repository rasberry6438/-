;-------------------------------------------------
;グラフィック関係を重置する
;画像の処理が終わった後に実行してください
;-------------------------------------------------
@EFFECT_ALLRESET
#DIM DYNAMIC LCOUNT

CBGCLEAR

FOR LCOUNT, 0, 50
	GDISPOSE LCOUNT
NEXT

Z_DEPTH = -2
NOW_Z_FADEOUT = 0
POPUP_SETG_COUNT = 0
POPUP_SETB_COUNT = 0
LETTERBOX_HEIGHT = 0

RETURN 1

;-------------------------------------------------
;画像を画面に表示してフェードアウトぽくする関数
;ARGSは色の指定、"FFFFFF"かDEF_COLOR()で指定できる文字
;ARG:0はフェードアウトまでの時間、1 = 0.1秒になる
;この関数の後は@FADEINかCBGCLEARで画面を戻せる
;-------------------------------------------------
@FADEOUT, ARGS, ARG = 2
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC MEMO_REDRAW
#DIM DYNAMIC AFTER_COLOR
#DIM DYNAMIC NOW_ALPHA
#DIM DYNAMIC PLUS_ALPHA

IF ARGS == ""
	AFTER_COLOR = GETDEFBGCOLOR()
ELSEIF ISNUMERIC(ARGS)
	AFTER_COLOR = TOINT(ARGS)
ELSE
	AFTER_COLOR = DEF_COLOR(ARGS)
ENDIF

MEMO_REDRAW = CURRENTREDRAW()
REDRAW 0

;ウィンドウと同サイズの画像を生成
IF GHEIGHT(23) != CLIENTHEIGHT()
	GDISPOSE 10
	GCREATE 10, CLIENTWIDTH(), CLIENTHEIGHT()
ENDIF

;0.1秒ごとに加算する数値
PLUS_ALPHA = (255 + (ARG - 1))/ ARG
NOW_Z_FADEOUT = Z_DEPTH

FOR LCOUNT, 0, ARG
	NOW_ALPHA = LIMIT(NOW_ALPHA + PLUS_ALPHA, 0, 255)
	GCLEAR 10, (NOW_ALPHA * 0x1000000) + AFTER_COLOR
	CBGREMOVERANGE NOW_Z_FADEOUT, NOW_Z_FADEOUT
	CBGSETG 10, 0, 0, NOW_Z_FADEOUT
	;100msより短い時間は動作を保証されていない
	TWAIT 100, 0
NEXT

REDRAW MEMO_REDRAW
Z_DEPTH -= 1

RETURN 1

;-------------------------------------------------
;画像を画面に表示してフェードインぽくする関数
;ARGSは色の指定、"FFFFFF"かDEF_COLOR()で指定できる文字
;ARG:0はフェードインまでの時間、1 = 0.1秒になる
;-------------------------------------------------
@FADEIN, ARGS, ARG = 2
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC MEMO_REDRAW
#DIM DYNAMIC BEFORE_COLOR
#DIM DYNAMIC NOW_ALPHA = 255
#DIM DYNAMIC MINUS_ALPHA

IF ARGS == ""
	BEFORE_COLOR = GETDEFBGCOLOR()
ELSEIF ISNUMERIC(ARGS)
	BEFORE_COLOR = TOINT(ARGS)
ELSE
	BEFORE_COLOR = DEF_COLOR(ARGS)
ENDIF

MEMO_REDRAW = CURRENTREDRAW()
REDRAW 0

;ウィンドウと同サイズの画像を生成
IF GHEIGHT(0) != CLIENTHEIGHT()
	GDISPOSE 10
	GCREATE 10, CLIENTWIDTH(), CLIENTHEIGHT()
ENDIF


;0.1秒ごとに減算する数値
MINUS_ALPHA = (255 + (ARG - 1))/ ARG

;フェードアウトしているか？
IF NOW_Z_FADEOUT == 0
	NOW_Z_FADEOUT = Z_DEPTH
	Z_DEPTH -= 1
ENDIF

FOR LCOUNT, 0, ARG
	NOW_ALPHA = LIMIT(NOW_ALPHA - MINUS_ALPHA, 0, 255)
	GCLEAR 10, (NOW_ALPHA * 0x1000000) + BEFORE_COLOR
	CBGREMOVERANGE NOW_Z_FADEOUT, NOW_Z_FADEOUT
	CBGSETG 10, 0, 0, NOW_Z_FADEOUT

	;100msより短い時間は動作を保証されいない
	TWAIT 100, 1
NEXT

CBGREMOVERANGE NOW_Z_FADEOUT, NOW_Z_FADEOUT
NOW_Z_FADEOUT = 0

REDRAW MEMO_REDRAW

RETURN 1

;-------------------------------------------------
;BACKGROUND_GSC, str spriteName
;背景画像を作り、上に黑色帯を出すことで映画っぽい画面にする
;ARGSには背景にしたいスプライトネームを入れる
;-------------------------------------------------
@BACKGROUND_GSC, ARGS

;再表示用に重置
CBGREMOVERANGE 1, 1

;背景画像の作成
CALL OVERLAY_GCREATE, 13, ARGS, CLIENTWIDTH(), CLIENTHEIGHT() - LETTERBOX_HEIGHT
SIF RESULT == 0		;作成失敗
	RETURN 0

;Z = 1に表示
CBGSETG 13, 0, 0, 1

RETURN 1
;-------------------------------------------------
;上部に背景色の帯を配置する
;この帯の高さはフォントが綺麗に収圆圈ように調整される
;-------------------------------------------------
@LETTERBOX_CREATE
#DIM DYNAMIC SPACE_HEIGHT

SPACE_HEIGHT = GETCONFIG("一行の高さ") + (CLIENTHEIGHT() % GETCONFIG("一行の高さ")) 

;再表示用に重置
LETTERBOX_HEIGHT = 0
CBGREMOVERANGE -50, -50

;黒帯の作成
CALL OVERLAY_GCREATE, 14, TOSTR(0xFF000000 + GETDEFBGCOLOR()), CLIENTWIDTH(), SPACE_HEIGHT
SIF RESULT == 0		;作成失敗
	RETURN 0

;Z = -50に表示（最前面になるように）
CBGSETG 14, X_ALIGN(CLIENTWIDTH(), "左"), Y_VALIGN(SPACE_HEIGHT, "上"), -50

LETTERBOX_HEIGHT = SPACE_HEIGHT

RETURN 1

;-------------------------------------------------
;POPUP_SSC, str spriteName, str 表示位置, int width, int height
;ウィンドウの指定した表示位置に画像を表示する
;ARGS:1に大まかな位置を入力する。他は一緒
;画像一個を出すだけならこれでOK
;左上｜ 上 ｜右上
;──┼──┼──
; 左 ｜中央｜ 右 
;──┼──┼──
;左下｜ 下 ｜右下
;-------------------------------------------------
@POPUP_SSC, ARGS:0, ARGS:1, ARG:0, ARG:1
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC SPLIT_COUNT
#DIM DYNAMIC GRAPHICS_XPOS
#DIM DYNAMIC GRAPHICS_YPOS
#DIM DYNAMIC GRAPHICS_WIDTH
#DIM DYNAMIC GRAPHICS_HEIGHT

GRAPHICS_WIDTH = ARG:0
GRAPHICS_HEIGHT = ARG:1

;ARGS:0の内容を分割してスプライトの名前を取り出す
VARSET LOCALS
SPLIT ARGS, "+", LOCALS
SPLIT_COUNT = RESULT

;画像の尺寸が決まっていないなら最初に認識されたスプライトの尺寸
IF GRAPHICS_WIDTH == 0 || GRAPHICS_HEIGHT == 0
	FOR LCOUNT, 0, SPLIT_COUNT
		IF SPRITECREATED(LOCALS:LCOUNT)
			GRAPHICS_WIDTH = SPRITEWIDTH(LOCALS:LCOUNT)
			GRAPHICS_HEIGHT = SPRITEHEIGHT(LOCALS:LCOUNT)
			BREAK
		ENDIF
	NEXT
ENDIF

;ここまでに尺寸が決まってなかったら中断
SIF GRAPHICS_WIDTH == 0 || GRAPHICS_HEIGHT == 0
	RETURN 0

;位置の決定
SELECTCASE ARGS:1
CASE "左上"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "左")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "上")
CASE "左"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "左")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "中央")
CASE "", "左下"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "左")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "下")
CASE "上"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "中央")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "上")
CASE "中央"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "中央")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "中央")
CASE "下"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "中央")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "下")
CASE "右上"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "右")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "上")
CASE "右"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "右")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "中央")
CASE "右下"
	GRAPHICS_XPOS = X_ALIGN(GRAPHICS_WIDTH, "右")
	GRAPHICS_YPOS = Y_VALIGN(GRAPHICS_HEIGHT, "下")
ENDSELECT

CALL POPUP_SPRIT, ARGS, GRAPHICS_XPOS, GRAPHICS_YPOS, GRAPHICS_WIDTH, GRAPHICS_HEIGHT
SIF RESULT == 0		;作成失敗
	RETURN 0

RETURN 1

;-------------------------------------------------
;POPUP_SPRIT, str spriteName, int x, int y, int width, int height
;ウィンドウの指定した位置に画像を表示する
;ARGS:0にはスプライトの名前、重ねて表示したい場合は"+"で区切る
;幅と高さの指定がない場合、最初に認識したスプライトの尺寸を参考にする
;-------------------------------------------------
@POPUP_SPRIT, ARGS, ARG:0, ARG:1, ARG:2, ARG:3
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC SPLIT_COUNT
#DIM DYNAMIC GRAPHICS_ID
#DIM DYNAMIC GRAPHICS_XPOS
#DIM DYNAMIC GRAPHICS_YPOS
#DIM DYNAMIC GRAPHICS_WIDTH
#DIM DYNAMIC GRAPHICS_HEIGHT

GRAPHICS_ID = POPUP_SETG_COUNT + 30
SIF GRAPHICS_ID >= 40
	RETURN 0
GRAPHICS_XPOS = ARG:0
GRAPHICS_YPOS = ARG:1
GRAPHICS_WIDTH = ARG:2
GRAPHICS_HEIGHT = ARG:3

;画像の作成
CALL OVERLAY_GCREATE, GRAPHICS_ID, ARGS, GRAPHICS_WIDTH, GRAPHICS_HEIGHT
SIF RESULT == 0		;作成失敗の場合は中断
	RETURN 0

;ボタンMapが作成されていないなら作成
SIF SPRITECREATED("BMP_WAINDOW") == 0
	CALL BMP_WINDOW_CREATE, 0xDF000000

CBGSETG GRAPHICS_ID, GRAPHICS_XPOS, GRAPHICS_YPOS, Z_DEPTH

Z_DEPTH -= 1
POPUP_SETG_COUNT += 1

RETURN 1
;-------------------------------------------------
;POPUP_BUTTON, str spriteName or str cARGB, int x, int y, int width, int height
;ARGS:0に入力したものがマウスカーソルを合わせると表示される
;スプライトの名前、もしくは"0xAARRGGBB"の形で色を入力する、空にするとなにも不顯示
;INPUTMOUSEKEYで返す値はボタンの作成した順番(0、1、2)、ボタンの配置が被ったりするとあとから作成した物が優先される
;@POPUP_SPRITの位置とサイズを合わせるようにするとよい
;-------------------------------------------------
@POPUP_BUTTON, ARGS, ARG:0, ARG:1, ARG:2, ARG:3
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC SPLIT_COUNT
#DIM DYNAMIC BUTTON_ID
#DIM DYNAMIC BUTTON_VALUE
#DIM DYNAMIC BUTTON_XPOS
#DIM DYNAMIC BUTTON_YPOS
#DIM DYNAMIC BUTTON_WIDTH
#DIM DYNAMIC BUTTON_HEIGHT
#DIMS DYNAMIC BUTTON_NAME

BUTTON_ID = POPUP_SETB_COUNT + 40
SIF BUTTON_ID >= 50
	RETURN 0
BUTTON_VALUE = POPUP_SETB_COUNT
BUTTON_XPOS = ARG:0
BUTTON_YPOS = ARG:1
BUTTON_WIDTH = ARG:2
BUTTON_HEIGHT = ARG:3
BUTTON_NAME = G_BUTTON%TOSTR(POPUP_SETB_COUNT, "D2")%


;マウスオーバー時の画像の作成
CALL OVERLAY_GCREATE, BUTTON_ID, ARGS, BUTTON_WIDTH, BUTTON_HEIGHT
SIF RESULT == 0		;作成失敗の場合は中断
	RETURN 0

;スプライトを作成
SPRITECREATE BUTTON_NAME, BUTTON_ID

;ボタンMapが作成されていないなら作成
SIF SPRITECREATED("BMP_WAINDOW") == 0
	CALL BMP_WINDOW_CREATE, 0xDF000000

;ボタンMapを解除
CBGREMOVEBMAP

;BMAPにボタンの位置を書き込む
GSETBRUSH 11, 0xFF000000 + BUTTON_VALUE
GFILLRECTANGLE 11, BUTTON_XPOS, (Y_VALIGN(BUTTON_HEIGHT, "上") * -1) + BUTTON_YPOS, BUTTON_WIDTH, BUTTON_HEIGHT		;GFILLRECTANGLEは左上基準なのでYの位置を補正する

;ボタンMap再表示
CBGSETBMAPG 11

;ボタン用の画像を表示
CBGSETBUTTONSPRITE BUTTON_VALUE, "", BUTTON_NAME, BUTTON_XPOS, BUTTON_YPOS, Z_DEPTH

Z_DEPTH -= 1
POPUP_SETB_COUNT += 1

RETURN 1

;-------------------------------------------------
;画像全体をボタン化させる ARGに0xAARRGGBBで色を付けることができる
;画面上のツールチップなどを無効化できます
;INPUTMOUSEKEYを使用時"999999"が返ってきます
;-------------------------------------------------
@BMP_WINDOW_CREATE, ARG

;ボタンMapの作製
GDISPOSE 11
GCREATE 11, CLIENTWIDTH(), CLIENTHEIGHT()
GCLEAR 11, 0xFF000000 + 999999
SIF CBGSETBMAPG(11) == 0
	RETURN 0

;ウィンドウ全体用の画像を作る
GDISPOSE 12
GCREATE 12, CLIENTWIDTH(), CLIENTHEIGHT()
SPRITECREATE "BMP_WAINDOW", 12
GCLEAR 12, ARG

;レイヤーに作成した画像を置く
SIF CBGSETBUTTONSPRITE(999999, "BMP_WAINDOW", "BMP_WAINDOW", 0, 0, -1)
	RETURN 0

RETURN 1

;-------------------------------------------------
;OVERLAY_GCREATE, int ID, str spriteName or str cARGB, int width, int height
;ARGS:0にスプライトの名前、もしくは"0xAARRGGBB"の形で色を入力する
;作成に成功すると1、失敗すると0を返します
;-------------------------------------------------
@OVERLAY_GCREATE, GRAPHICS_ID, ARGS, GRAPHICS_WIDTH, GRAPHICS_HEIGHT
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC SPLIT_COUNT
#DIM DYNAMIC GRAPHICS_ID
#DIM DYNAMIC GRAPHICS_WIDTH
#DIM DYNAMIC GRAPHICS_HEIGHT
#DIMS DYNAMIC SPRITE_NAME
#DIMS DYNAMIC SPRITE_COLOR
#DIMS DYNAMIC SPLIT_STR, 100
#DIM MEMO_TIME


;ARGS:0の内容を分割してスプライトの名前を取り出す
SPLIT ARGS, "+", SPLIT_STR
SPLIT_COUNT = RESULT


;画像の尺寸が決まっていないなら最初に認識されたスプライトの尺寸
IF !GRAPHICS_WIDTH || !GRAPHICS_HEIGHT
	FOR LCOUNT, 0, SPLIT_COUNT
		IF SPRITECREATED(SPLIT_STR:LCOUNT)
			GRAPHICS_WIDTH = SPRITEWIDTH(SPLIT_STR:LCOUNT)
			GRAPHICS_HEIGHT = SPRITEHEIGHT(SPLIT_STR:LCOUNT)
			BREAK
		ENDIF
	NEXT
ENDIF

;ここまでに尺寸が決まってなかったら中断
SIF !GRAPHICS_WIDTH || !GRAPHICS_HEIGHT
	RETURN 0

;作成済みの場合は書き換える
IF !GCREATE(GRAPHICS_ID, GRAPHICS_WIDTH, GRAPHICS_HEIGHT)
	GDISPOSE GRAPHICS_ID
	GCREATE GRAPHICS_ID, GRAPHICS_WIDTH, GRAPHICS_HEIGHT

	;GRAPHICS_IDが颜绘orCIPのものなら、STRにこのスプライトに対応する颜绘文字列を記録
	SELECTCASE GRAPHICS_ID
	CASE 2000 TO 2500, 3000 TO 3500
		STR:GRAPHICS_ID = %ARGS%
	ENDSELECT
ENDIF

;重ね作業
FOR LCOUNT, 0, SPLIT_COUNT
	;デバッグ用
	;PRINTFORML %SPLIT_STR:LCOUNT%
	
	IF SPRITECREATED(SPLIT_STR:LCOUNT)
		GDRAWSPRITE GRAPHICS_ID, SPLIT_STR:LCOUNT, 0, 0, GRAPHICS_WIDTH, GRAPHICS_HEIGHT
		CONTINUE
	ELSEIF ISNUMERIC(SPLIT_STR:LCOUNT)
		GSETBRUSH GRAPHICS_ID, TOINT(SPLIT_STR:LCOUNT)
		GFILLRECTANGLE GRAPHICS_ID, 0, 0, GRAPHICS_WIDTH, GRAPHICS_HEIGHT
		CONTINUE
	ELSEIF STRCOUNT(SPLIT_STR:LCOUNT, "\[槞\]")
		SPRITE_NAME = %EXTSTR(SPLIT_STR:LCOUNT, "", "\[")%槞
		GDRAWSPRITE GRAPHICS_ID, SPRITE_NAME, 0, 0, GRAPHICS_WIDTH, GRAPHICS_HEIGHT
		CONTINUE
	ENDIF

	SPRITE_NAME = %EXTSTR(SPLIT_STR:LCOUNT, "", "\[")%
	SPRITE_COLOR = %EXTSTR(SPLIT_STR:LCOUNT, "\[", "\]")%

	;3追加髪型1
	IF STRCOUNT(SPRITE_NAME, "^3[^0-9]")
		CALL GET_COLOR_MATRIX_ELEMENTS, "髪色の種類", SPRITE_COLOR
	;4後髪
	ELSEIF STRCOUNT(SPRITE_NAME, "^4[^0-9]")
		IF STRCOUNT(SPRITE_NAME, "简易扎发バレッタカラー")
			CALL GET_COLOR_MATRIX_ELEMENTS, "简易扎发バレッタカラー", SPRITE_COLOR
		ELSE
			CALL GET_COLOR_MATRIX_ELEMENTS, "髪色の種類", SPRITE_COLOR
		ENDIF
	;6追加髪型2
	ELSEIF STRCOUNT(SPRITE_NAME, "^6[^0-9]")
		CALL GET_COLOR_MATRIX_ELEMENTS, "髪色の種類", SPRITE_COLOR
	;7肌
	ELSEIF STRCOUNT(SPRITE_NAME, "^7[^0-9]")
		IF STRCOUNT(SPRITE_NAME, "肩の血色")
			CALL GET_COLOR_MATRIX_ELEMENTS, "肩の血色", SPRITE_COLOR
		ELSE
			CALL GET_COLOR_MATRIX_ELEMENTS, "顔の色", SPRITE_COLOR
		ENDIF
	;8頬
	ELSEIF STRCOUNT(SPRITE_NAME, "^8[^0-9]")
		IF STRCOUNT(SPRITE_NAME, "脸谱")
			CALL GET_COLOR_MATRIX_ELEMENTS, "脸谱", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "赤面")
			CALL GET_COLOR_MATRIX_ELEMENTS, "赤面の色", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "战妆")
			CALL GET_COLOR_MATRIX_ELEMENTS, "战妆", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "頬汗")
			CALL GET_COLOR_MATRIX_ELEMENTS, "頬汗", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "頬傷")
			CALL GET_COLOR_MATRIX_ELEMENTS, "頬傷", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "頬創口貼")
			CALL GET_COLOR_MATRIX_ELEMENTS, "頬創口貼", SPRITE_COLOR
		ELSE
			CALL GET_COLOR_MATRIX_ELEMENTS, "脸颊カラー", SPRITE_COLOR
		ENDIF
	;11目
	ELSEIF STRCOUNT(SPRITE_NAME, "^11[^0-9]")
		;色関係ないもの
		IF STRCOUNTS(SPRITE_NAME, "高光", "爱心眼")
			CONTINUE
		ELSEIF STRCOUNTS(SPRITE_NAME, "まつ毛", "眯眯眼", "闭眼", "笑颜")
			CALL GET_COLOR_MATRIX_ELEMENTS, "まつ毛の色", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "白眼")
			CALL GET_COLOR_MATRIX_ELEMENTS, "白眼", SPRITE_COLOR
		ELSEIF STRCOUNTS(SPRITE_NAME, "２", "３", "４", "５", "６")
			CALL GET_COLOR_MATRIX_ELEMENTS, "瞳色２", SPRITE_COLOR
		ELSE
			CALL GET_COLOR_MATRIX_ELEMENTS, "瞳色", SPRITE_COLOR
		ENDIF
	;12耳
	ELSEIF STRCOUNT(SPRITE_NAME, "^12[^0-9]")
		IF STRCOUNT(SPRITE_NAME, "人鱼耳")
			CALL GET_COLOR_MATRIX_ELEMENTS, "髪色の種類", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "動物")
			IF STRCOUNT(SPRITE_NAME, "内耳")
				CALL GET_COLOR_MATRIX_ELEMENTS, "動物耳内耳", SPRITE_COLOR
			ELSE
				CALL GET_COLOR_MATRIX_ELEMENTS, "髪色の種類", SPRITE_COLOR
			ENDIF
		ELSE
			CALL GET_COLOR_MATRIX_ELEMENTS, "顔の色", SPRITE_COLOR
		ENDIF
	;14特徴2
	ELSEIF STRCOUNT(SPRITE_NAME, "^14[^0-9]")
		IF STRCOUNTS(SPRITE_NAME, "羽")
			CALL GET_COLOR_MATRIX_ELEMENTS, "翼の色", SPRITE_COLOR
		ELSE
			CALL GET_COLOR_MATRIX_ELEMENTS, "角の色", SPRITE_COLOR
		ENDIF
	;16前髪
	ELSEIF STRCOUNT(SPRITE_NAME, "^16[^0-9]")
		IF STRCOUNT(SPRITE_NAME, "長鬓角髪飾２")
			CALL GET_COLOR_MATRIX_ELEMENTS, "長鬓角髪飾２", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "長鬓角髪飾")
			CALL GET_COLOR_MATRIX_ELEMENTS, "長鬓角髪飾", SPRITE_COLOR
		ELSE
			CALL GET_COLOR_MATRIX_ELEMENTS, "髪色の種類", SPRITE_COLOR
		ENDIF
	;17挑染
	ELSEIF STRCOUNT(SPRITE_NAME, "^17[^0-9]")
		CALL GET_COLOR_MATRIX_ELEMENTS, "髪色の種類", SPRITE_COLOR
	;18眉
	ELSEIF STRCOUNT(SPRITE_NAME, "^18[^0-9]")
		CALL GET_COLOR_MATRIX_ELEMENTS, "眉の色", SPRITE_COLOR
	;19特徴3
	ELSEIF STRCOUNT(SPRITE_NAME, "^19[^0-9]")
		IF STRCOUNT(SPRITE_NAME, "呆毛")
			CALL GET_COLOR_MATRIX_ELEMENTS, "髪色の種類", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "角")
			CALL GET_COLOR_MATRIX_ELEMENTS, "角の色", SPRITE_COLOR
		ELSE
			CONTINUE
		ENDIF
	;22其他
	ELSEIF STRCOUNT(SPRITE_NAME, "^22[^0-9]")
		IF STRCOUNT(SPRITE_NAME, "目陰")
			CALL GET_COLOR_MATRIX_ELEMENTS, "顔の色", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "手首")
			CALL GET_COLOR_MATRIX_ELEMENTS, "手首の色", SPRITE_COLOR
		ELSEIF STRCOUNT(SPRITE_NAME, "スマホ")
			CALL GET_COLOR_MATRIX_ELEMENTS, "スマホカラー", SPRITE_COLOR
		ELSE
			CONTINUE
		ENDIF
	;陰毛
	ELSEIF STRCOUNT(SPRITE_NAME, "陰毛")
		CALL GET_COLOR_MATRIX_ELEMENTS, "陰毛の色", SPRITE_COLOR
	ELSE
		CONTINUE
	ENDIF

;	MEMO_TIME = GETMILLISECOND()

	GDRAWSPRITE GRAPHICS_ID, SPRITE_NAME, 0, 0, GRAPHICS_WIDTH, GRAPHICS_HEIGHT, COLOR_MATRIX_ELEMENTS:0:0

;	PRINTFORMW %SPRITE_NAME%の所要時間：{GETMILLISECOND() - MEMO_TIME}

NEXT

RETURN 1

;-------------------------------------------------
;左阴蒂ック、エンターキー、Escキー、時間切れのみ進めるWAIT
;画面をスクロール出来なくすることができる
;ARGが0だと時間切れ无
;-------------------------------------------------
@SWAIT, ARG

WHILE 1
	INPUTMOUSEKEY ARG

	IF RESULT:0 == 1	;マウス押下が検出された
		IF RESULT:1 == 0x100000	;左阴蒂ック
			BREAK
		ENDIF
	ELSEIF RESULT:0 == 3; キーボード押下が検出された
		IF RESULT:1 == 0x0D			;エンター
			BREAK
		ELSEIF RESULT:1 == 0x1B		;Esc
			BREAK
		ENDIF
	ELSEIF RESULT:0 == 4	;時間切れにより終了した
		BREAK
	ENDIF
WEND

RETURN 1
;-------------------------------------------------
;POPUP_BUTTONで作成したボタンを押すまでループさせる
;ARGに時間を指定できるが、枠外を阴蒂ックすると時間が重置されるので放置した場合のみの時間になる
;念のためEscでも終了するようにしてます
;返り値はPOPUP_RESULTでも見る事が出来ます
;-------------------------------------------------
@POPUP_SELECT, ARG

POPUP_RESULT = 0

WHILE 1
	INPUTMOUSEKEY ARG
	IF RESULT:0 == 1	;マウス押下が検出された
		IF RESULT:1 == 0x100000
			IF RESULT:4 == 999999
			ELSEIF RESULT:4 >= 0
				POPUP_RESULT = RESULT:4
				BREAK
			ENDIF
		ENDIF
	ELSEIF RESULT:0 == 3; キーボード押下が検出された
		IF RESULT:1 == 0x1B
			POPUP_RESULT = -99
			BREAK
		ENDIF
	ELSEIF RESULT:0 == 4	;時間切れにより終了した
		POPUP_RESULT = -1
		BREAK
	ENDIF
WEND

RETURN POPUP_RESULT

;-------------------------------------------------
;画像を画面のどこに表示するかの座標を作成する
;ARGは画像の横幅、ARGSは表示位置を入れる
;
;ARGSの位置
; 左 ｜中央｜ 右
;-------------------------------------------------
@X_ALIGN(ARG, ARGS)
#FUNCTION
#DIM DYNAMIC X_POS
#DIM DYNAMIC WINDOW_WIDTH

WINDOW_WIDTH = CLIENTWIDTH()

SELECTCASE ARGS
CASE "左"
	X_POS = 0
CASE "中央"
	X_POS = (WINDOW_WIDTH / 2) - (ARG / 2)
CASE "右"
	X_POS = WINDOW_WIDTH - ARG
ENDSELECT

RETURNF X_POS
;-------------------------------------------------
;画像を画面のどこに表示するかの座標を作成する
;ARGは画像の縦幅、ARGSは表示位置を入れる
;ARGSの位置
; 上
;──
;中央
;──
; 下
;-------------------------------------------------
@Y_VALIGN(ARG, ARGS)
#FUNCTION
#DIM DYNAMIC Y_POS
#DIM DYNAMIC WINDOW_HEIGHT

WINDOW_HEIGHT = CLIENTHEIGHT()

SELECTCASE ARGS
CASE "上"
	Y_POS = (WINDOW_HEIGHT - LETTERBOX_HEIGHT - ARG) * -1
CASE "中央"
	Y_POS = (((WINDOW_HEIGHT - LETTERBOX_HEIGHT) / 2) - (ARG / 2)) * -1
CASE "下"
	Y_POS = 0
ENDSELECT

RETURNF Y_POS

